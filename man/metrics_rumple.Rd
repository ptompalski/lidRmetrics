% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/metrics_rumple.R
\docType{data}
\name{metrics_rumple}
\alias{metrics_rumple}
\alias{.metrics_rumple}
\title{Calculate rumple index}
\format{
An object of class \code{formula} of length 2.
}
\usage{
metrics_rumple(x, y, z, pixel_size, zmin = NA)

.metrics_rumple
}
\arguments{
\item{x, y, z}{X, Y, Z coordinates of a point cloud}

\item{pixel_size}{pixel size}

\item{zmin}{numeric. Minimum \code{z} value. If set, \code{z} values (heights) below are ignored in calculations.}
}
\value{
Same as \code{lidR::rumple_index} - the calculated rumple index
}
\description{
A wrapper of the \code{lidR::rumple_index} function that allows to calculate rumple index without the need for CHM, and 
can be used directly in the e.g. \code{pixel_metrics} function. The function combines the two required steps, 
i.e. creating a surface model, and calculating rumple index, into one.
Top surface is created using highest points within each pixel.
}
\examples{
library(lidR)
library(lidRmetrics)
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
las <- readLAS(LASfile, select = "*", filter = "-keep_random_fraction 0.5")

m1 <- cloud_metrics(las, ~metrics_rumple(x = X, y = Y, z = Z, pixel_size = 1))

m2 <- pixel_metrics(las, ~metrics_rumple(x = X, y = Y, z = Z, pixel_size = 1), res = 20)
}
\keyword{datasets}
